# Copyright 2023 Cloudera, Inc.
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

---

# test06-gateway.3-10-18-234.pvc.cloudera-labs.com
# test06-freeipa.67-99-7-45.pvc.cloudera-labs.com
# test06-worker-01.cldr.deployment
# test06-worker-02.cldr.deployment
# test06-master-01.cldr.deployment

- name: Provision AWS infrastructure
  hosts: localhost
  connection: local
  gather_facts: no
  tags: infra
  tasks:
    - name: Set Terraform variables
      ansible.builtin.template:
        dest: tf_cluster/terraform.tfvars
        src: infra.tfvars.j2
    
    - name: Check for existing Terraform state file
      ansible.builtin.stat:
        path: tf_cluster/terraform.tfstate
      register: __tf_state

    - name: Establish the infrastructure
      cloud.terraform.terraform:
        project_path: "tf_cluster/"
        state: "present"
        force_init: "{{ not __tf_state.stat.exists }}"
        provider_upgrade: true

    - name: Establish the Ansible inventory from the infrastructure
      ansible.builtin.meta: refresh_inventory

- name: Ensure inventory readiness
  hosts: all
  gather_facts: no
  tags: always
  tasks:
    - name: Check if host is ready
      ansible.builtin.wait_for_connection:
        timeout: 60

- name: Prepare and mount storage volumes
  hosts: all 
  gather_facts: no
  become: yes
  tags: infra
  tasks:
    - name: Prepare storage volumes
      when: storage_volumes is defined and storage_volumes | length > 0
      ansible.builtin.import_role:
        name: cloudera.exe.mount
      vars:
        mount_volumes: "{{ storage_volumes }}"
        mount_provider: "{{ infra_type }}"

- name: Enable and configure host services
  hosts: all
  gather_facts: no
  become: yes
  tags: system
  tasks:
    - name: Retrieve service facts
      ansible.builtin.service_facts:

    - name: Install rngd service
      when: not (ansible_facts.services | dict2items | map(attribute='value') | selectattr('name', 'eq', 'rngd') | list)
      ansible.builtin.package:
        name: rng-tools
        state: latest

    - name: Enable rngd service
      ansible.builtin.service:
        name: rngd
        enabled: yes
        state: started
      
    - name: Configure kernel parameters
      ansible.posix.sysctl:
        name: "{{ __sysctl.key }}"
        value: "{{ __sysctl.value | string }}"
        state: present
        reload: yes
      loop: "{{ params | dict2items }}"
      loop_control:
        loop_var: __sysctl
        label: "{{ __sysctl.key }}"
      vars:
       params:
        vm.swappiness: 1
        net.ipv6.conf.all.disable_ipv6: 1
        net.ipv6.conf.default.disable_ipv6: 1
        net.ipv6.conf.lo.disable_ipv6: 0
      register: __kernel

    - name: Set timezone to UTC
      community.general.timezone:
        hwclock: UTC

    - name: Disable firewalld
      when: ansible_facts.services | dict2items | map(attribute="value") | selectattr('name', 'eq', 'firewalld') | list
      ansible.builtin.service:
        name: firewalld
        enabled: no
        state: stopped

    - name: Disable SELinux
      ansible.posix.selinux:
        state: disabled
        update_kernel_param: yes
      register: __selinux

    - name: Reboot host
      when: __kernel.changed or __selinux.reboot_required
      ansible.builtin.reboot:

- name: Provision dnsmasq services
  hosts: dnsmasq
  gather_facts: no
  become: yes
  tags:
    - dnsmasq_server
    - dnsmasq
  vars:
    vpc_cidr: "{{ lookup('cloud.terraform.tf_output', 'vpc', project_path='tf_cluster')['cidr_block'] }}"
  tasks:
    - name: Set up dnsmasq server
      ansible.builtin.import_role:
        name: dnsmasq_server
      vars:
        dnsmasq_upstream_nameservers: ["{{ vpc_cidr | ansible.utils.ipmath(2) }}"]
        dnsmasq_realm: "{{ freeipa.realm | lower }}"
        dnsmasq_ldap_servers: "{{ groups['freeipa'] }}"
        dnsmasq_kerberos_servers: "{{ groups['freeipa'] }}"

    # Add dns-rr records for URI records for KRB KDC discovery
    # https://sigmaris.info/blog/2018/04/encoding-dns-uri-records-for-dnsmasq/
    # dns-rr=_kerberos.cldr.deployment,256,000a00016b7262357372763a6d3a7463703a7465737430362d667265656970612d30312e31382d3139312d3132382d3234362e7076632e636c6f75646572612d6c6162732e636f6d2e
    # dns-rr=_kerberos.cldr.deployment,256,000a00016b7262357372763a6d3a7564703a7465737430362d667265656970612d30312e31382d3139312d3132382d3234362e7076632e636c6f75646572612d6c6162732e636f6d2e
    # dns-rr=_kpasswd.cldr.deployment,256,000a00016b7262357372763a6d3a7463703a7465737430362d667265656970612d30312e31382d3139312d3132382d3234362e7076632e636c6f75646572612d6c6162732e636f6d2e
    # dns-rr=_kpasswd.cldr.deployment,256,000a00016b7262357372763a6d3a7564703a7465737430362d
    # 667265656970612d30312e31382d3139312d3132382d3234362e7076632e636c6f75646572612d6c616273
    # 2e636f6d2e

- name: Establish DNS resolution to dnsmasq server
  hosts: all:!dnsmasq
  gather_facts: no
  become: yes
  tags: 
    - dnsmasq_client
    - dnsmasq
  tasks:
    - name: Gather network details for all hosts
      ansible.builtin.setup:
        gather_subset: network
      delegate_to: "{{ item }}"
      delegate_facts: true
      run_once: yes
      loop: "{{ groups['dnsmasq'] }}"

    - name: Set up DNS resolution
      ansible.builtin.import_role:
        name: dnsmasq_client
      vars:
        dnsmasq_nameservers: "{{ groups['dnsmasq'] | map('extract', hostvars, morekeys=['ansible_default_ipv4']) | map(attribute='address') | list }}"

- name: Provision FreeIPA services
  hosts: freeipa
  gather_facts: yes
  become: yes
  tags:
    - freeipa
    - freeipa_server
  vars:
    vpc_cidr: "{{ lookup('cloud.terraform.tf_output', 'vpc', project_path='tf_cluster')['cidr_block'] }}"
    le_certs:
      - "isrgrootx1.pem"
      - "isrg-root-x2.pem"
      - "lets-encrypt-r3.pem"
      - "lets-encrypt-e1.pem"
      - "lets-encrypt-r4.pem"
      - "lets-encrypt-e2.pem"
  tasks:
    - name: Install base FreeIPA server packages
      ansible.builtin.package:
        name: "{{ item }}"
        state: present
      loop:
        - "@idm:DL1:8090020231016161112/server"
        - "@idm:DL1:8090020231016161112/dns"
        - "@idm:DL1:8090020231016161112/client"

    - name: Set up the local FreeIPA server
      ansible.builtin.import_role:
        name: freeipa.ansible_freeipa.ipaserver
      vars:
        state: present
        ipaserver_install_packages: no
        ipaserver_hostname: "{{ inventory_hostname }}"
        ipaserver_realm: "{{ freeipa.realm }}"
        ipaserver_domain: "{{ freeipa.realm | lower }}"
        ipaserver_no_host_dns: yes
        ipaserver_setup_firewalld: no
        ipaserver_setup_dns: no
        #ipaserver_copy_csr_to_controller: yes
        ipaserver_ca_subject: "CN=CLDR-{{ name_prefix }}-RootCA,O={{ freeipa.realm }}"
        ipaclient_servers: ["{{ inventory_hostname }}"]
        ipaclient_mkhomedir: yes
        ipadm_password: "{{ freeipa.ipaadmin_password | default(lookup('env', 'IPA_PASSWORD', default='Undefined')) }}"
        ipaadmin_password: "{{ freeipa.ipaadmin_password | default(lookup('env', 'IPA_PASSWORD', default='Undefined')) }}"
    
    - name: Import the EPEL GPG key
      ansible.builtin.rpm_key:
        key: "https://dl.fedoraproject.org/pub/epel/RPM-GPG-KEY-EPEL-{{ ansible_distribution_major_version }}"
      register: gpg_install
      until: gpg_install is succeeded
      retries: 5
      delay: 10

    - name: Enable the EPEL repository
      ansible.builtin.yum:
        name: "https://dl.fedoraproject.org/pub/epel/epel-release-latest-{{ ansible_facts['distribution_major_version'] }}.noarch.rpm"
      register: repo_install
      until: repo_install is succeeded
      retries: 5
      delay: 10
      
    - name: Install snap
      ansible.builtin.package:
        name: snapd

    - name: Enable the snapd daemon
      ansible.builtin.service:
        name: snapd.socket
        enabled: yes
        state: started

    - name: Create the snap 'classic' symlink
      ansible.builtin.file:
        src: /var/lib/snapd/snap
        dest: /snap
        state: link
      register: __snap_classic
    
    - name: Reboot the server to set up the snap paths
      when: __snap_classic.changed
      ansible.builtin.reboot:
    
    - name: Install certbot (via command)
      ansible.builtin.command: 
        cmd: snap install certbot --classic
        creates: /snap/bin/certbot

    # - name: Create the certbot symlink
    #   ansible.builtin.file:
    #     src: /snap/bin/certbot
    #     dest: /usr/bin/certbot
    #     state: link
    
    - name: Set up the SSL directory
      ansible.builtin.file:
        path: "/etc/ssl/{{ inventory_hostname }}"
        state: directory

    - name: Download the Lets Encrypt root certificates
      ansible.builtin.get_url:
        dest: "/etc/ssl/{{ inventory_hostname }}"
        url: "{{ le_cert_url }}"
      loop: "{{ ['https://letsencrypt.org/certs/'] | product(le_certs) | map('join') | list }}"
      loop_control:
        loop_var: le_cert_url
      register: __le_certs

    - debug:
        var: __le_certs

    - name: Install the Lets Encrypt root certificates in the FreeIPA CA
      when: not __le_certs.results | rejectattr('changed') | list
      ansible.builtin.command:
        argv:
          - ipa-cacert-manage
          - install
          - "{{ le_cert }}"
      loop: "{{ __le_certs.results | map(attribute='dest') | list }}"
      loop_control:
        loop_var: le_cert

    - name: Update the FreeIPA CA system
      when: not __le_certs.results | rejectattr('changed') | list
      ansible.builtin.command: ipa-certupdate

    - name: Install the Lets Encrypt certificate renewal script
      ansible.builtin.template:
        dest: /root/renew-le.sh
        src: renew-le.sh.j2
        mode: "0755"

    - name: Install the Lets Encrypt certificate signing request configuration
      ansible.builtin.template:
        dest: /root/ipa-httpd.cnf
        src: ipa-httpd.cnf.j2
        mode: "0644"

    - name: Set up a daily cron job to check the Lets Encrypt certificate
      ansible.builtin.cron:
        name: letsencrypt renewal
        hour: "2"
        user: root
        job: /root/renew-le.sh
        cron_file: letsencrypt_renewal

    - name: Run the Lets Encrypt certificate renewal script
      ansible.builtin.command: /root/renew-le.sh --first-time

- name: Register all hosts with local FreeIPA server
  hosts: all:!freeipa
  gather_facts: yes
  become: yes
  tags:
    - freeipa
    - freeipa_client
  tasks:
  - name: Set up the FreeIPA Client
    ansible.builtin.include_role:
      name: freeipa.ansible_freeipa.ipaclient
    vars:
      state: present
      ipaclient_hostname: "{{ inventory_hostname }}"
      ipaclient_servers: "{{ groups['freeipa'] }}"
      ipaclient_mkhomedir: yes
      ipaserver_domain: "{{ freeipa.realm | lower }}"
      ipaserver_realm: "{{ freeipa.realm }}"
      ipaserver_setup_dns: no
      ipaadmin_principal: "{{ freeipa.ipaadmin_user | default(lookup('ansible.builtin.env', 'IPA_USER', default=omit)) }}"
      ipaadmin_password: "{{ freeipa.ipaadmin_password | default(lookup('ansible.builtin.env', 'IPA_PASSWORD', default='Undefined')) }}"

    - name: Update SSSD to enable Kerberos file ticket caching
      ansible.builtin.import_role:
        name: krb_file_ticket_cache
      vars:
        sssd_domain: "{{ domain }}"
        
- name: Establish supporting services resources
  hosts: deployment
  gather_facts: no
  become: yes
  tags: prereq
  tasks:
    - name: Establish additional cluster host requirements
      ansible.builtin.import_role:
        name: cluster_reqs
